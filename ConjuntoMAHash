package prueba2;
import java.util.*;

public class ConjuntoAC implements Conjunto {

	//-------------------------------------------------------------------------------------------------------------------//
	// La implementaci�n est�tica "normal" de ConjuntoTDA. Los elementos se almacenan en un arreglo. Dado que el orden   //
	// no interesa, se agregan siempre al final. Para sacar un elemento, se lo reemplaza por el de la �ltima posici�n.   //
	// El m�todo "elegir" puede elegir cualquiera de los n�meros que pueblan el conjunto. Aqu� se elige, "por decreto",  //
	// el primero de todos. Hay otras posibilidades, como el de la implementaci�n "COnjuntoAR".                          //
	// Estas implementaciones son comparativamente ineficientes. Un "hashmap" es la mejor estructura.                    //
	//-------------------------------------------------------------------------------------------------------------------//
	
	char[] arr;		// Aqu� se guardan los n�meros del conjunto. El orden es irrelevante, por supuesto.
	int cant;
	HashMap<Character, Integer> mapaElementos;
	
	@Override
	public void inicializarConjunto() {	// El costo es O(1). Todas las operaciones tienen costo constante. 
		arr = new char[20];				// Se puede usar cualquier n�mero para especificar el tama�o m�ximo del conjunto.
		cant = 0;
		mapaElementos = new HashMap<>();
	}

	@Override
	public void agregar(char x) {		
		if (!this.pertenece(x))	{		// S�lo se agrega el elemento si no est� ya en el arreglo. 
			arr[cant] = x;
			mapaElementos.put(x, cant);
			cant++;
		}
	}

	@Override
	public void sacar(char x) {				
		int i = mapaElementos.get(x);
		if (i != -1) {
			arr[i] = arr[cant-1];			// Se sobreescribe con el �ltimo elemento.
			cant--;							// Y se decrementa "cant". 
		}
	}

	@Override
	public char elegir() {					// En este caso, el costo es O(1).
		return arr[0];
	}

	@Override
	public boolean pertenece(char x) {	
		return (mapaElementos.containsKey(x));					// Si es -1, no se lo encontr�; en caso contrario, s�. 
	}

	@Override
	public boolean conjuntoVacio() {		// El costo es O(1)
		return (cant == 0);					// Observe que la condici�n "cant == 0" es equivalente a "el conjunto est� vac�o."
	}
	
}
